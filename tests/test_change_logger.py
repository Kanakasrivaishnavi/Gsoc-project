import unittest
import tempfile
import os
import json
from unittest.mock import Mock, patch
from datetime import datetime
import sys

# Add the project root to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from src.ols_fetch_from_github.change_logger import ChangeLogger


class TestChangeLogger(unittest.TestCase):
    """Test cases for ChangeLogger class"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.test_dir = tempfile.mkdtemp()
        self.logger = ChangeLogger(log_dir=self.test_dir)
        
        # Sample changes data based on actual SBO data structure
        self.sample_changes = {
            'has_changes': True,
            'stats': {
                'terms_added': 2,
                'terms_deleted': 1,
                'terms_updated': 3,
                'typedefs_added': 1,
                'typedefs_deleted': 0,
                'typedefs_updated': 1,
                'header_updated': True
            },
            'header_changes': {
                'format-version': {
                    'old': '1.2',
                    'new': '1.2'
                },
                'remark': {
                    'old': 'Systems Biology Ontology, OWL export generated by SBO Browser (http://www.ebi.ac.uk/sbo/)',
                    'new': 'Systems Biology Ontology, OWL export generated by SBO Browser (http://www.ebi.ac.uk/sbo/)'
                },
                'ontology': {
                    'old': 'http://biomodels.net/SBO/',
                    'new': 'http://biomodels.net/SBO/'
                },
                'property_value': {
                    'old': 'owl:versionInfo "28:08:2021 03:13" xsd:string',
                    'new': 'owl:versionInfo "15:05:2023 10:30" xsd:string'
                },
                'name': {
                    'old': 'Generated: 03:11:2021 07:00',
                    'new': 'Generated: 15:05:2023 10:30'
                }

            },
            'term_changes': {
                'added': [
                    {
                        'id': 'SBO:0000001',
                        'name': 'rate law',
                        'comment': 'mathematical description that relates quantities of reactants to the reaction velocity.',
                        'is_a': [{'id': 'SBO:0000064', 'name': 'mathematical expression'}]
                    }
                ],
                'deleted': [
                    {
                        'id': 'SBO:0000002',
                        'name': 'quantitative systems description parameter',
                        'comment': 'A numerical value that defines certain characteristics of systems or system functions.',
                        'is_a': [{'id': 'SBO:0000545', 'name': 'systems description parameter'}]
                    }
                ],
                'updated': [
                    {
                        'id': 'SBO:0000003',
                        'old_term': {
                            'id': 'SBO:0000003',
                            'name': 'participant role',
                            'comment': 'The function of a physical or conceptual entity, that is its role, in the execution of an event or process.',
                            'is_a': [{'id': 'SBO:0000000', 'name': 'systems biology representation'}]
                        },
                        'new_term': {
                            'id': 'SBO:0000003',
                            'name': 'participant role',
                            'comment': 'Updated: The function of a physical or conceptual entity, that is its role, in the execution of an event or process.',
                            'is_a': [{'id': 'SBO:0000000', 'name': 'systems biology representation'}]
                        },
                        'field_changes': {
                            'comment': {'action': 'updated', 'old': 'The function of a physical or conceptual entity, that is its role, in the execution of an event or process.', 'new': 'Updated: The function of a physical or conceptual entity, that is its role, in the execution of an event or process.'}
                        }
                    }
                ]
            },
            'typedef_changes': {
                'added': [
                    {
                        'id': 'part:of',
                        'name': 'part of',
                        'is_transitive': 'true'
                    }
                ],
                'deleted': [],
                'updated': [
                    {
                        'id': 'has_part',
                        'old_typedef': {
                            'id': 'has_part',
                            'name': 'has part',
                            'is_transitive': 'false'
                        },
                        'new_typedef': {
                            'id': 'has_part',
                            'name': 'has part',
                            'is_transitive': 'true'
                        },
                        'field_changes': {
                            'is_transitive': {'action': 'updated', 'old': 'false', 'new': 'true'}
                        }
                    }
                ]
            }
        }
        
        self.no_changes = {
            'has_changes': False,
            'stats': {
                'terms_added': 0,
                'terms_deleted': 0,
                'terms_updated': 0,
                'typedefs_added': 0,
                'typedefs_deleted': 0,
                'typedefs_updated': 0,
                'header_updated': False
            }
        }
    
    def tearDown(self):
        """Clean up test fixtures"""
        import shutil
        shutil.rmtree(self.test_dir, ignore_errors=True)
    
    def test_init_default_log_dir(self):
        """Test initialization with default log directory"""
        logger = ChangeLogger()
        
        # Should create log directory under SBO_OBO_Files/logs
        expected_path_suffix = os.path.join('SBO_OBO_Files', 'logs')
        self.assertTrue(logger.log_dir.endswith(expected_path_suffix))
    
    def test_init_custom_log_dir(self):
        """Test initialization with custom log directory"""
        custom_dir = os.path.join(self.test_dir, 'custom_logs')
        logger = ChangeLogger(log_dir=custom_dir)
        
        self.assertEqual(logger.log_dir, custom_dir)
        self.assertTrue(os.path.exists(custom_dir))
    
    def test_ensure_log_dir_creates_directory(self):
        """Test that log directory is created if it doesn't exist"""
        new_dir = os.path.join(self.test_dir, 'new_logs')
        logger = ChangeLogger(log_dir=new_dir)
        
        self.assertTrue(os.path.exists(new_dir))
    
    def test_log_changes_success(self):
        """Test successful change logging"""
        old_version = {'sha': 'abc123', 'date': '2023-01-01'}
        new_version = {'sha': 'def456', 'date': '2023-02-01'}
        
        with patch('src.ols_fetch_from_github.change_logger.datetime') as mock_datetime:
            mock_now = Mock()
            mock_now.strftime.return_value = '20230515_103045'
            mock_now.isoformat.return_value = '2023-05-15T10:30:45'
            mock_datetime.now.return_value = mock_now
            
            result = self.logger.log_changes(self.sample_changes, old_version, new_version)
        
        self.assertIsNotNone(result)
        self.assertTrue(result.endswith('sbo_changes_20230515_103045.json'))
        self.assertTrue(os.path.exists(result))
        
        # Verify log file content
        with open(result, 'r', encoding='utf-8') as f:
            log_data = json.load(f)
        
        self.assertEqual(log_data['timestamp'], '2023-05-15T10:30:45')
        self.assertEqual(log_data['old_version'], old_version)
        self.assertEqual(log_data['new_version'], new_version)
        self.assertEqual(log_data['summary'], self.sample_changes['stats'])
        self.assertIn('changes', log_data)
    
    def test_log_changes_no_changes(self):
        """Test logging when no changes are present"""
        result = self.logger.log_changes(self.no_changes)
        
        self.assertIsNone(result)
    
    def test_log_changes_none_input(self):
        """Test logging with None input"""
        result = self.logger.log_changes(None)
        
        self.assertIsNone(result)
    
    def test_log_changes_file_write_error(self):
        """Test logging when file write fails"""
        # Create a read-only directory to simulate write error
        readonly_dir = os.path.join(self.test_dir, 'readonly')
        os.makedirs(readonly_dir)
        os.chmod(readonly_dir, 0o444)
        
        logger = ChangeLogger(log_dir=readonly_dir)
        
        try:
            result = logger.log_changes(self.sample_changes)
            # Should return None on write failure
            self.assertIsNone(result)
        finally:
            # Restore permissions for cleanup
            os.chmod(readonly_dir, 0o755)
    
    def test_format_term_changes_added(self):
        """Test formatting of added terms"""
        term_changes = {
            'added': [
                {
                    'id': 'SBO:0000001',
                    'name': 'rate law',
                    'comment': 'mathematical description',
                    'is_a': [{'id': 'SBO:0000064', 'name': 'mathematical expression'}]
                }
            ],
            'deleted': [],
            'updated': []
        }
        
        result = self.logger._format_term_changes(term_changes)
        
        self.assertEqual(len(result['added']), 1)
        added_term = result['added'][0]
        self.assertEqual(added_term['obo_id'], 'SBO:0000001')
        self.assertEqual(added_term['label'], 'rate law')
        self.assertEqual(added_term['description'], 'mathematical description')
        self.assertEqual(added_term['change_type'], 'add')
        self.assertEqual(len(added_term['parents']), 1)
        self.assertEqual(added_term['parents'][0]['parent_id'], 'SBO:0000064')
    
    def test_format_term_changes_updated(self):
        """Test formatting of updated terms"""
        term_changes = {
            'added': [],
            'deleted': [],
            'updated': [
                {
                    'id': 'SBO:0000001',
                    'old_term': {
                        'id': 'SBO:0000001',
                        'name': 'old name',
                        'comment': 'old comment'
                    },
                    'new_term': {
                        'id': 'SBO:0000001',
                        'name': 'new name',
                        'comment': 'new comment'
                    },
                    'field_changes': {
                        'name': {'action': 'updated'},
                        'comment': {'action': 'updated'}
                    }
                }
            ]
        }
        
        result = self.logger._format_term_changes(term_changes)
        
        self.assertEqual(len(result['updated']), 1)
        updated_term = result['updated'][0]
        self.assertEqual(updated_term['obo_id'], 'SBO:0000001')
        self.assertEqual(updated_term['label'], 'new name')
        self.assertEqual(updated_term['description'], 'new comment')
        self.assertEqual(updated_term['change_type'], 'update')
        self.assertIn('field_changes', updated_term)
        self.assertIn('old_values', updated_term)
        self.assertEqual(updated_term['old_values']['label'], 'old name')
    
    def test_format_typedef_changes(self):
        """Test formatting of typedef changes"""
        typedef_changes = {
            'added': [
                {
                    'id': 'part:of',
                    'name': 'part of',
                    'is_transitive': 'true'
                }
            ],
            'deleted': [],
            'updated': []
        }
        
        result = self.logger._format_typedef_changes(typedef_changes)
        
        self.assertEqual(len(result['added']), 1)
        added_typedef = result['added'][0]
        self.assertEqual(added_typedef['obo_id'], 'part:of')
        self.assertEqual(added_typedef['label'], 'part of')
        self.assertEqual(added_typedef['description'], 'No description')  # Default when no 'def' field
        self.assertEqual(added_typedef['change_type'], 'add')
    
    def test_get_parent_info_dict_format(self):
        """Test getting parent info from dict format"""
        term = {
            'is_a': [
                {'id': 'SBO:0000001', 'name': 'parent 1'},
                {'id': 'SBO:0000002', 'name': 'parent 2'}
            ]
        }
        
        result = self.logger._get_parent_info(term)
        
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['parent_id'], 'SBO:0000001')
        self.assertEqual(result[0]['parent_label'], 'parent 1')
        self.assertEqual(result[1]['parent_id'], 'SBO:0000002')
        self.assertEqual(result[1]['parent_label'], 'parent 2')
    
    def test_get_parent_info_string_format(self):
        """Test getting parent info from string format"""
        term = {
            'is_a': ['SBO:0000001', 'SBO:0000002']
        }
        
        result = self.logger._get_parent_info(term)
        
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['parent_id'], 'SBO:0000001')
        self.assertEqual(result[0]['parent_label'], 'Unknown')
        self.assertEqual(result[1]['parent_id'], 'SBO:0000002')
        self.assertEqual(result[1]['parent_label'], 'Unknown')
    
    def test_get_parent_info_single_dict(self):
        """Test getting parent info from single dict"""
        term = {
            'is_a': {'id': 'SBO:0000001', 'name': 'parent'}
        }
        
        result = self.logger._get_parent_info(term)
        
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['parent_id'], 'SBO:0000001')
        self.assertEqual(result[0]['parent_label'], 'parent')
    
    def test_get_parent_info_single_string(self):
        """Test getting parent info from single string"""
        term = {
            'is_a': 'SBO:0000001'
        }
        
        result = self.logger._get_parent_info(term)
        
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['parent_id'], 'SBO:0000001')
        self.assertEqual(result[0]['parent_label'], 'Unknown')
    
    def test_get_parent_info_empty(self):
        """Test getting parent info when no is_a field"""
        term = {}
        
        result = self.logger._get_parent_info(term)
        
        self.assertEqual(len(result), 0)
    
    @patch('builtins.print')
    def test_display_change_summary_with_changes(self, mock_print):
        """Test displaying change summary with changes"""
        self.logger.display_change_summary(self.sample_changes)
        
        # Check that print was called with expected content
        calls = [call[0][0] for call in mock_print.call_args_list]
        summary_text = '\n'.join(calls)
        
        self.assertIn('Change Summary', summary_text)
        self.assertIn('Added: 2', summary_text)
        self.assertIn('Deleted: 1', summary_text)
        self.assertIn('Updated: 3', summary_text)
        self.assertIn('Header: Updated', summary_text)
        self.assertIn('Total changes:', summary_text)
    
    @patch('builtins.print')
    def test_display_change_summary_no_changes(self, mock_print):
        """Test displaying change summary with no changes"""
        self.logger.display_change_summary(self.no_changes)
        
        mock_print.assert_called_with("âœ… No changes found")
    
    @patch('builtins.print')
    def test_display_detailed_changes(self, mock_print):
        """Test displaying detailed changes"""
        self.logger.display_detailed_changes(self.sample_changes, limit=2)
        
        calls = [call[0][0] for call in mock_print.call_args_list]
        detailed_text = '\n'.join(calls)
        
        self.assertIn('Added Terms', detailed_text)
        self.assertIn('Deleted Terms', detailed_text)
        self.assertIn('Updated Terms', detailed_text)
        self.assertIn('SBO:0000001', detailed_text)
        self.assertIn('SBO:0000002', detailed_text)
        self.assertIn('SBO:0000003', detailed_text)
    
    @patch('builtins.print')
    def test_display_detailed_changes_no_changes(self, mock_print):
        """Test displaying detailed changes with no changes"""
        self.logger.display_detailed_changes(self.no_changes)
        
        # Should not print anything for no changes
        mock_print.assert_not_called()
    
    def test_format_term_changes_with_missing_fields(self):
        """Test formatting terms with missing optional fields"""
        term_changes = {
            'added': [
                {
                    'id': 'SBO:0000001',
                    'name': 'minimal term'
                    # Missing comment, def, is_a fields
                }
            ],
            'deleted': [],
            'updated': []
        }
        
        result = self.logger._format_term_changes(term_changes)
        
        self.assertEqual(len(result['added']), 1)
        added_term = result['added'][0]
        self.assertEqual(added_term['obo_id'], 'SBO:0000001')
        self.assertEqual(added_term['label'], 'minimal term')
        self.assertEqual(added_term['description'], 'No description')
        self.assertEqual(len(added_term['parents']), 0)
    
    def test_format_typedef_changes_with_missing_fields(self):
        """Test formatting typedefs with missing optional fields"""
        typedef_changes = {
            'added': [
                {
                    'id': 'minimal_typedef',
                    'name': 'minimal typedef'
                    # Missing def, is_transitive fields
                }
            ],
            'deleted': [],
            'updated': []
        }
        
        result = self.logger._format_typedef_changes(typedef_changes)
        
        self.assertEqual(len(result['added']), 1)
        added_typedef = result['added'][0]
        self.assertEqual(added_typedef['obo_id'], 'minimal_typedef')
        self.assertEqual(added_typedef['label'], 'minimal typedef')
        self.assertEqual(added_typedef['description'], 'No description')


if __name__ == '__main__':
    unittest.main()