import unittest
import tempfile
import os
from unittest.mock import Mock, patch, MagicMock
import sys

# Add the project root to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from src.ols_fetch_from_github.file_validator import FileValidator
from src.ols_fetch_from_github.utils import ValidationResult


class TestFileValidator(unittest.TestCase):
    """Test cases for FileValidator class"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.validator = FileValidator()
        
        # Sample OBO content
        self.sample_obo_content = """format-version: 1.2
remark: Systems Biology Ontology, OWL export generated by SBO Browser (http://www.ebi.ac.uk/sbo/)
ontology: http://biomodels.net/SBO/
property_value: owl:versionInfo "28:08:2021 03:13" xsd:string
name: Generated: 03:11:2021 07:00

[Term]
id: SBO:0000001
name: rate law
comment: mathematical description that relates quantities of reactants to the reaction velocity.
is_a: SBO:0000064 ! mathematical expression

[Term]
id: SBO:0000002
name: quantitative systems description parameter
comment: A numerical value that defines certain characteristics of systems or system functions.
is_a: SBO:0000545 ! systems description parameter
"""
    
    def test_validate_json_structure_valid(self):
        """Test validating valid JSON structure"""
        valid_data = {
            "header": {
                "format-version": "1.2",
                "remark": "Systems Biology Ontology, OWL export generated by SBO Browser (http://www.ebi.ac.uk/sbo/)",
                "ontology": "http://biomodels.net/SBO/",
                "property_value": "owl:versionInfo \"28:08:2021 03:13\" xsd:string",
                "name": "Generated: 03:11:2021 07:00"
            },
            "terms": [
                {
                    "id": "SBO:0000001",
                    "name": "rate law",
                    "comment": "mathematical description that relates quantities of reactants to the reaction velocity.",
                    "is_a": [
                        {
                            "id": "SBO:0000064",
                            "name": "mathematical expression"
                        }
                    ]
                },
                {
                    "id": "SBO:0000002", 
                    "name": "quantitative systems description parameter",
                    "comment": "A numerical value that defines certain characteristics of systems or system functions.",
                    "is_a": [
                        {
                            "id": "SBO:0000545",
                            "name": "systems description parameter"
                        }
                    ]
                }
            ],
            "typedefs": [
                {
                    "id": "part:of",
                    "name": "part of",
                    "is_transitive": "true"
                }
            ]
        }
        
        result = self.validator.validate_json_structure(valid_data)
        
        self.assertIsInstance(result, ValidationResult)
        self.assertTrue(result.success)
        self.assertEqual(result.message, "JSON structure validation passed")
        
        # Check statistics
        stats = result.data
        self.assertEqual(stats['header_fields'], 5)
        self.assertEqual(stats['total_terms'], 2)
        self.assertTrue(stats['has_typedefs'])
        self.assertEqual(stats['typedef_count'], 1)
    
    def test_validate_json_structure_missing_header(self):
        """Test validating JSON with missing header"""
        invalid_data = {
            "terms": []
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Missing required field: header", result.message)
    
    def test_validate_json_structure_missing_terms(self):
        """Test validating JSON with missing terms"""
        invalid_data = {
            "header": {}
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Missing required field: terms", result.message)
    
    def test_validate_json_structure_invalid_header_type(self):
        """Test validating JSON with invalid header type"""
        invalid_data = {
            "header": "should be object",
            "terms": []
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Header field must be an object", result.message)
    
    def test_validate_json_structure_invalid_terms_type(self):
        """Test validating JSON with invalid terms type"""
        invalid_data = {
            "header": {},
            "terms": "should be array"
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Terms field must be an array", result.message)
    
    def test_validate_json_structure_invalid_term_type(self):
        """Test validating JSON with invalid term type"""
        invalid_data = {
            "header": {},
            "terms": ["should be object"]
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Term 1 is not an object", result.message)
    
    def test_validate_json_structure_term_missing_id(self):
        """Test validating JSON with term missing id"""
        invalid_data = {
            "header": {},
            "terms": [
                {
                    "name": "missing id term"
                }
            ]
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Term 1 missing id field", result.message)
    
    def test_validate_json_structure_term_missing_name(self):
        """Test validating JSON with term missing name"""
        invalid_data = {
            "header": {},
            "terms": [
                {
                    "id": "SBO:0000001"
                }
            ]
        }
        
        result = self.validator.validate_json_structure(invalid_data)
        
        self.assertFalse(result.success)
        self.assertIn("Term 1 missing name field", result.message)
    
    def test_validate_json_structure_exception(self):
        """Test validation with exception during processing"""
        # Cause an exception by passing None
        result = self.validator.validate_json_structure(None)
        
        self.assertFalse(result.success)
        self.assertIn("Error during validation", result.message)
    
    @patch('src.ols_fetch_from_github.file_validator.subprocess.run')
    def test_run_git_diff_success(self, mock_run):
        """Test successful git diff execution"""
        mock_result = Mock()
        mock_result.stdout = "diff output"
        mock_result.stderr = ""
        mock_result.returncode = 0
        mock_run.return_value = mock_result
        
        stdout, stderr, code = self.validator._run_git_diff("file1.txt", "file2.txt")
        
        self.assertEqual(stdout, "diff output")
        self.assertEqual(stderr, "")
        self.assertEqual(code, 0)
        
        # Verify command
        expected_cmd = ['git', 'diff', '--no-index', 'file1.txt', 'file2.txt']
        mock_run.assert_called_once_with(expected_cmd, capture_output=True, text=True)
    
    @patch('src.ols_fetch_from_github.file_validator.subprocess.run')
    def test_run_git_diff_with_options(self, mock_run):
        """Test git diff with options"""
        mock_result = Mock()
        mock_result.stdout = ""
        mock_result.stderr = ""
        mock_result.returncode = 0
        mock_run.return_value = mock_result
        
        self.validator._run_git_diff("file1.txt", "file2.txt", ['--ignore-all-space'])
        
        expected_cmd = ['git', 'diff', '--no-index', '--ignore-all-space', 'file1.txt', 'file2.txt']
        mock_run.assert_called_once_with(expected_cmd, capture_output=True, text=True)
    
    @patch('src.ols_fetch_from_github.file_validator.subprocess.run')
    def test_run_git_diff_exception(self, mock_run):
        """Test git diff with exception"""
        mock_run.side_effect = Exception("Git error")
        
        stdout, stderr, code = self.validator._run_git_diff("file1.txt", "file2.txt")
        
        self.assertIsNone(stdout)
        self.assertEqual(stderr, "Git error")
        self.assertEqual(code, 1)
    
    def test_extract_semantic_content(self):
        """Test extracting semantic content from OBO file"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f:
            f.write(self.sample_obo_content)
            temp_file = f.name
        
        try:
            content = self.validator._extract_semantic_content(temp_file)
            
            self.assertIsInstance(content, set)
            self.assertIn('format-version: 1.2', content)
            self.assertIn('ontology: http://biomodels.net/SBO/', content)
            self.assertIn('[Term]', content)
            self.assertIn('id: SBO:0000001', content)
            self.assertIn('name: rate law', content)
            
            # Should not contain empty lines or comments
            self.assertNotIn('', content)
            
        finally:
            os.unlink(temp_file)
    
    def test_validate_semantic_content_identical(self):
        """Test semantic validation of identical files"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f1:
            f1.write(self.sample_obo_content)
            file1 = f1.name
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f2:
            f2.write(self.sample_obo_content)
            file2 = f2.name
        
        try:
            result = self.validator.validate_semantic_content(file1, file2)
            self.assertTrue(result)
        finally:
            os.unlink(file1)
            os.unlink(file2)
    
    def test_validate_semantic_content_different(self):
        """Test semantic validation of different files"""
        content1 = self.sample_obo_content
        content2 = content1.replace("rate law", "different name")
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f1:
            f1.write(content1)
            file1 = f1.name
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f2:
            f2.write(content2)
            file2 = f2.name
        
        try:
            result = self.validator.validate_semantic_content(file1, file2)
            self.assertFalse(result)
        finally:
            os.unlink(file1)
            os.unlink(file2)
    
    def test_validate_semantic_content_exception(self):
        """Test semantic validation with exception"""
        result = self.validator.validate_semantic_content("nonexistent1.txt", "nonexistent2.txt")
        self.assertFalse(result)
    
    @patch.object(FileValidator, '_run_git_diff')
    def test_validate_roundtrip_conversion_identical(self, mock_git_diff):
        """Test roundtrip validation with identical files"""
        # Mock git diff to return no differences
        mock_git_diff.return_value = ("", "", 0)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f1:
            f1.write(self.sample_obo_content)
            file1 = f1.name
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f2:
            f2.write(self.sample_obo_content)
            file2 = f2.name
        
        try:
            result = self.validator.validate_roundtrip_conversion(file1, file2)
            self.assertTrue(result)
        finally:
            os.unlink(file1)
            os.unlink(file2)
    
    def test_validate_roundtrip_conversion_original_missing(self):
        """Test roundtrip validation with missing original file"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f:
            f.write(self.sample_obo_content)
            existing_file = f.name
        
        try:
            result = self.validator.validate_roundtrip_conversion("nonexistent.obo", existing_file)
            self.assertFalse(result)
        finally:
            os.unlink(existing_file)
    
    def test_validate_roundtrip_conversion_converted_missing(self):
        """Test roundtrip validation with missing converted file"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f:
            f.write(self.sample_obo_content)
            existing_file = f.name
        
        try:
            result = self.validator.validate_roundtrip_conversion(existing_file, "nonexistent.obo")
            self.assertFalse(result)
        finally:
            os.unlink(existing_file)
    
    @patch.object(FileValidator, '_run_git_diff')
    def test_validate_roundtrip_conversion_git_error(self, mock_git_diff):
        """Test roundtrip validation with git error"""
        mock_git_diff.return_value = ("", "Git error", 1)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f1:
            f1.write(self.sample_obo_content)
            file1 = f1.name
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f2:
            f2.write(self.sample_obo_content)
            file2 = f2.name
        
        try:
            result = self.validator.validate_roundtrip_conversion(file1, file2)
            self.assertFalse(result)
        finally:
            os.unlink(file1)
            os.unlink(file2)
    
    @patch.object(FileValidator, '_run_git_diff')
    @patch.object(FileValidator, 'validate_semantic_content')
    def test_validate_roundtrip_conversion_semantic_fallback(self, mock_semantic, mock_git_diff):
        """Test roundtrip validation falling back to semantic comparison"""
        # Mock git diff to show differences
        mock_git_diff.side_effect = [
            ("differences", "", 0),  # First call - has differences
            ("differences", "", 0)   # Second call - still has differences with options
        ]
        
        # Mock semantic validation to pass
        mock_semantic.return_value = True
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f1:
            f1.write(self.sample_obo_content)
            file1 = f1.name
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.obo', delete=False) as f2:
            f2.write(self.sample_obo_content)
            file2 = f2.name
        
        try:
            result = self.validator.validate_roundtrip_conversion(file1, file2)
            self.assertTrue(result)
            
            # Should have called semantic validation
            mock_semantic.assert_called_once_with(file1, file2)
        finally:
            os.unlink(file1)
            os.unlink(file2)


if __name__ == '__main__':
    unittest.main()