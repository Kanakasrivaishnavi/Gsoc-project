import unittest
import tempfile
import os
import json
import shutil
from unittest.mock import Mock, patch, MagicMock, ANY
from io import StringIO
import sys

# Add the project root to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from src.ols_fetch_from_github.main_workflow import SBOWorkflowManager, main




class TestSBOWorkflowManager(unittest.TestCase):
    """Test cases for SBOWorkflowManager class"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.test_dir = tempfile.mkdtemp()
        self.original_cwd = os.getcwd()
        
        # Create test directory structure
        self.system_files_dir = os.path.join(self.test_dir, 'SBO_OBO_Files')
        self.localfiles_dir = os.path.join(self.system_files_dir, 'localfiles')
        os.makedirs(self.localfiles_dir)
        
        # Copy config.json to test directory structure so Config can find it
        config_source = os.path.join(os.path.dirname(__file__), '..', 'src', 'ols_fetch_from_github', 'config.json')
        # Create the src/ols_fetch_from_github directory structure in test directory
        self.test_src_dir = os.path.join(self.test_dir, 'src', 'ols_fetch_from_github')
        os.makedirs(self.test_src_dir)
        config_dest = os.path.join(self.test_src_dir, 'config.json')
        shutil.copy2(config_source, config_dest)
        
        # Create mock config
        self.mock_config = Mock()
        self.mock_config.github_url = 'https://raw.githubusercontent.com/EBI-BioModels/SBO/master/SBO_OBO.obo'
        self.mock_config.github_repo_owner = 'EBI-BioModels'
        self.mock_config.github_repo_name = 'SBO'
        self.mock_config.github_file_path = 'SBO_OBO.obo'
        self.mock_config.timestamp_format = '%Y%m%d_%H%M%S'
        
        # Sample data based on actual SBO structure
        self.sample_json_data = {
            'header': {
                'format-version': '1.2',
                'remark': 'Systems Biology Ontology, OWL export generated by SBO Browser (http://www.ebi.ac.uk/sbo/)',
                'ontology': 'http://biomodels.net/SBO/',
                'property_value': 'owl:versionInfo "28:08:2021 03:13" xsd:string',
                'name': 'Generated: 03:11:2021 07:00'
            },
            'terms': [
                {
                    'id': 'SBO:0000001',
                    'name': 'rate law',
                    'comment': 'mathematical description that relates quantities of reactants to the reaction velocity.',
                    'is_a': [{'id': 'SBO:0000064', 'name': 'mathematical expression'}]
                }
            ],
            'typedefs': [
                {
                    'id': 'part:of',
                    'name': 'part of',
                    'is_transitive': 'true'
                }
            ]
        }
        
        self.sample_changes = {
            'has_changes': True,
            'stats': {
                'terms_added': 1,
                'terms_deleted': 0,
                'terms_updated': 1,
                'typedefs_added': 0,
                'typedefs_deleted': 0,
                'typedefs_updated': 0,
                'header_updated': True
            },
            'term_changes': {
                'added': [
                    {
                        'id': 'SBO:0000001',
                        'name': 'rate law',
                        'comment': 'mathematical description that relates quantities of reactants to the reaction velocity.',
                        'is_a': [{'id': 'SBO:0000064', 'name': 'mathematical expression'}]
                    }
                ],
                'deleted': [],
                'updated': []
            },
            'typedef_changes': {
                'added': [],
                'deleted': [],
                'updated': []
            }
        }
        
        self.sample_update_info = {
            'temp_obo_file': '/tmp/temp_file.obo',
            'temp_json_file': '/tmp/temp_file.json',
            'remote_info': {
                'sha': 'abc123',
                'last_modified': '2023-05-15T10:30:45Z'
            },
            'changes': self.sample_changes,
            'has_changes': True
        }
        
        # Mock components
        self.mock_github_updater = Mock()
        self.mock_user_processor = Mock()
    
    def tearDown(self):
        """Clean up test fixtures"""
        os.chdir(self.original_cwd)
        shutil.rmtree(self.test_dir, ignore_errors=True)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_init(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test initialization"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
        
        self.assertIsNone(manager.active_file)
        self.assertEqual(manager.github_updater, self.mock_github_updater)
        self.assertEqual(manager.user_processor, self.mock_user_processor)
        
        # Check directory creation
        self.assertTrue(os.path.exists(self.system_files_dir))
        self.assertTrue(os.path.exists(self.localfiles_dir))
        
        # Check GitHubFileUpdater initialization - it should be called with a real Config instance
        mock_github_updater_class.assert_called_once()
        
        mock_user_processor_class.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_run_workflow_with_updates(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test run_workflow with updates available"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_check_for_updates') as mock_check_updates:
                with patch.object(manager, '_handle_updates_available') as mock_handle_updates:
                    with patch.object(manager, '_show_active_file') as mock_show_active:
                        mock_check_updates.return_value = self.sample_update_info
                        
                        manager.run_workflow()
        
        mock_check_updates.assert_called_once()
        mock_handle_updates.assert_called_once_with(self.sample_update_info)
        mock_show_active.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_run_workflow_no_updates(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test run_workflow with no updates available"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_check_for_updates') as mock_check_updates:
                with patch.object(manager, '_handle_no_updates') as mock_handle_no_updates:
                    with patch.object(manager, '_show_active_file') as mock_show_active:
                        mock_check_updates.return_value = None
                        
                        manager.run_workflow()
        
        mock_check_updates.assert_called_once()
        mock_handle_no_updates.assert_called_once()
        mock_show_active.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_check_for_updates_needs_update(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test check for updates when update is needed"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        self.mock_github_updater.get_update_status.return_value = {'needs_update': True}
        self.mock_github_updater.auto_download_update.return_value = self.sample_update_info
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            result = manager._check_for_updates()
        
        self.assertEqual(result, self.sample_update_info)
        self.mock_github_updater.get_update_status.assert_called_once()
        self.mock_github_updater.auto_download_update.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_check_for_updates_no_update(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test check for updates when no update is needed"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        self.mock_github_updater.get_update_status.return_value = {'needs_update': False}
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            result = manager._check_for_updates()
        
        self.assertIsNone(result)
        self.mock_github_updater.get_update_status.assert_called_once()
        self.mock_github_updater.auto_download_update.assert_not_called()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_check_for_updates_exception(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test check for updates when exception occurs"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        self.mock_github_updater.get_update_status.side_effect = Exception("Update check failed")
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            result = manager._check_for_updates()
        
        self.assertIsNone(result)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='1')  # User chooses "Yes"
    @patch('builtins.print')
    def test_handle_updates_available_apply_yes(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle updates available when user chooses to apply"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        self.mock_github_updater.apply_downloaded_update.return_value = True
        
        # Create a test JSON file
        test_json_file = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        with open(test_json_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_display_update_changes') as mock_display:
                with patch.object(manager, '_find_latest_json_file', return_value=test_json_file):
                    manager._handle_updates_available(self.sample_update_info)
        
        self.assertEqual(manager.active_file, test_json_file)
        mock_display.assert_called_once_with(self.sample_changes)
        self.mock_github_updater.apply_downloaded_update.assert_called_once_with(self.sample_update_info)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='2')  # User chooses "No"
    @patch('builtins.print')
    def test_handle_updates_available_apply_no(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle updates available when user chooses not to apply"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_display_update_changes') as mock_display:
                with patch.object(manager, '_handle_no_update_choice') as mock_handle_no_choice:
                    manager._handle_updates_available(self.sample_update_info)
        
        mock_display.assert_called_once_with(self.sample_changes)
        self.mock_github_updater.cleanup_temp_update.assert_called_once_with(self.sample_update_info)
        mock_handle_no_choice.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('src.ols_fetch_from_github.change_logger.ChangeLogger')
    @patch('builtins.print')
    def test_display_update_changes(self, mock_print, mock_logger_class, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test display update changes"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        mock_logger = Mock()
        mock_logger_class.return_value = mock_logger
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            manager._display_update_changes(self.sample_changes)
        
        mock_logger.display_change_summary.assert_called_once_with(self.sample_changes)
        mock_logger.display_detailed_changes.assert_called_once_with(self.sample_changes, limit=3)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_display_update_changes_no_changes(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test display update changes when no changes"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            manager._display_update_changes(None)
        
        mock_print.assert_called_with("  No detailed changes available")
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_handle_no_updates_with_existing_file(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no updates when existing file is available"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        # Create a test JSON file
        test_json_file = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        with open(test_json_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            # Override the system_files_dir to match our test directory structure
            manager.system_files_dir = self.system_files_dir
            
            with patch.object(manager, '_handle_no_update_choice') as mock_handle_no_choice:
                manager._handle_no_updates()
        
        mock_handle_no_choice.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_handle_no_updates_no_existing_file(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no updates when no existing file"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_no_existing_file') as mock_handle_no_existing:
                manager._handle_no_updates()
        
        mock_handle_no_existing.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='1')  # User chooses "Upload your own file"
    @patch('builtins.print')
    def test_handle_no_update_choice_upload(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no update choice when user chooses to upload"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_file_upload') as mock_handle_upload:
                manager._handle_no_update_choice()
        
        mock_handle_upload.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='2')  # User chooses "Use current file"
    @patch('builtins.print')
    def test_handle_no_update_choice_use_current(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no update choice when user chooses to use current file"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        # Create a test JSON file
        test_json_file = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        with open(test_json_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            # Override the system_files_dir to match our test directory structure
            manager.system_files_dir = self.system_files_dir
            manager._handle_no_update_choice()
        
        self.assertEqual(manager.active_file, test_json_file)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='1')  # User chooses "Upload your own file"
    @patch('builtins.print')
    def test_handle_no_existing_file_upload(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no existing file when user chooses to upload"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_file_upload') as mock_handle_upload:
                manager._handle_no_existing_file()
        
        mock_handle_upload.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='2')  # User chooses "Try to download latest file"
    @patch('builtins.print')
    def test_handle_no_existing_file_download_success(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no existing file when user chooses to download and succeeds"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        self.mock_github_updater.auto_download_update.return_value = {'temp_obo_file': 'temp.obo', 'temp_json_file': 'temp.json'}
        self.mock_github_updater.apply_downloaded_update.return_value = True
        
        # Create a test JSON file
        test_json_file = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        with open(test_json_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_find_latest_json_file', return_value=test_json_file):
                manager._handle_no_existing_file()
        
        self.assertEqual(manager.active_file, test_json_file)
        self.mock_github_updater.auto_download_update.assert_called_once()
        self.mock_github_updater.apply_downloaded_update.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='2')  # User chooses "Try to download latest file"
    @patch('builtins.print')
    def test_handle_no_existing_file_download_failure(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test handle no existing file when user chooses to download but fails"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        self.mock_github_updater.auto_download_update.return_value = None
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_file_upload') as mock_handle_upload:
                manager._handle_no_existing_file()
        
        mock_handle_upload.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='/path/to/test.json')
    @patch('builtins.print')
    def test_handle_file_upload_success(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test successful file upload"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        # Create a test file
        test_file = os.path.join(self.test_dir, 'test.json')
        with open(test_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        self.mock_user_processor.process_user_file.return_value = (True, test_file, "Success message")
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch('builtins.input', return_value=test_file):
                manager._handle_file_upload()
        
        self.assertEqual(manager.active_file, test_file)
        self.mock_user_processor.process_user_file.assert_called_once_with(test_file)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='')
    @patch('builtins.print')
    def test_handle_file_upload_empty_path(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test file upload with empty path"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_file_upload_failed') as mock_handle_failed:
                manager._handle_file_upload()
        
        mock_handle_failed.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='/nonexistent/file.json')
    @patch('builtins.print')
    def test_handle_file_upload_nonexistent_file(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test file upload with nonexistent file"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_file_upload_failed') as mock_handle_failed:
                manager._handle_file_upload()
        
        mock_handle_failed.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='1')  # User chooses "Re-upload"
    @patch('builtins.print')
    def test_handle_file_upload_failed_retry(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test file upload failed when user chooses to retry"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            
            with patch.object(manager, '_handle_file_upload') as mock_handle_upload:
                manager._handle_file_upload_failed()
        
        mock_handle_upload.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', return_value='2')  # User chooses "Use current file"
    @patch('builtins.print')
    def test_handle_file_upload_failed_use_current(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test file upload failed when user chooses to use current file"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        # Create a test JSON file
        test_json_file = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        with open(test_json_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            # Override the system_files_dir to match our test directory structure
            manager.system_files_dir = self.system_files_dir
            manager._handle_file_upload_failed()
        
        self.assertEqual(manager.active_file, test_json_file)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_find_latest_json_file_with_files(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test finding latest JSON file when files exist"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        # Create test JSON files with different timestamps
        file1 = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        file2 = os.path.join(self.localfiles_dir, 'SBO_OBO_20230516_103045.json')
        file3 = os.path.join(self.localfiles_dir, 'SBO_OBO_20230514_103045.json')
        
        for file_path in [file1, file2, file3]:
            with open(file_path, 'w') as f:
                json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            # Override the system_files_dir to match our test directory structure
            manager.system_files_dir = self.system_files_dir
            result = manager._find_latest_json_file()
        
        # Should return the lexicographically latest file (20230516)
        self.assertEqual(result, file2)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_find_latest_json_file_no_files(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test finding latest JSON file when no files exist"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            # Override the system_files_dir to match our test directory structure
            manager.system_files_dir = self.system_files_dir
            result = manager._find_latest_json_file()
        
        self.assertIsNone(result)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.input', side_effect=['invalid', '0', '3', '1'])  # Invalid inputs then valid choice
    @patch('builtins.print')
    def test_get_user_choice_invalid_then_valid(self, mock_print, mock_input, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test get user choice with invalid inputs then valid choice"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            result = manager._get_user_choice("Test prompt", ["Option 1", "Option 2"])
        
        self.assertEqual(result, "Option 1")
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_show_active_file_with_file(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test show active file when file exists"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        # Create a test JSON file
        test_json_file = os.path.join(self.localfiles_dir, 'SBO_OBO_20230515_103045.json')
        with open(test_json_file, 'w') as f:
            json.dump(self.sample_json_data, f)
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            manager.active_file = test_json_file
            manager._show_active_file()
        
        # Check that print was called with file information
        mock_print.assert_called()
        calls = [call[0][0] for call in mock_print.call_args_list]
        output_text = '\n'.join(calls)
        self.assertIn('Active file is', output_text)
        self.assertIn('Header fields count:', output_text)
        self.assertIn('Terms count:', output_text)
        self.assertIn('Typedefs count:', output_text)
        self.assertIn('File size:', output_text)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    @patch('builtins.print')
    def test_show_active_file_no_file(self, mock_print, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test show active file when no file exists"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            manager.active_file = None
            manager._show_active_file()
        
        mock_print.assert_called()
        calls = [call[0][0] for call in mock_print.call_args_list]
        output_text = '\n'.join(calls)
        self.assertIn('No active file', output_text)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_get_active_file(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test get active file"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        test_file = '/path/to/test.json'
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            manager.active_file = test_file
            result = manager.get_active_file()
        
        self.assertEqual(result, test_file)
    
    @patch('src.ols_fetch_from_github.main_workflow.GitHubFileUpdater')
    @patch('src.ols_fetch_from_github.main_workflow.UserFileProcessor')
    @patch('src.ols_fetch_from_github.main_workflow.os.chdir')
    def test_cleanup(self, mock_chdir, mock_user_processor_class, mock_github_updater_class):
        """Test cleanup restores working directory"""
        mock_github_updater_class.return_value = self.mock_github_updater
        mock_user_processor_class.return_value = self.mock_user_processor
        
        original_cwd = os.getcwd()
        
        with patch('src.ols_fetch_from_github.main_workflow.os.path.dirname', return_value=self.test_src_dir):
            manager = SBOWorkflowManager()
            manager.original_cwd = original_cwd
            manager.cleanup()
        
        # Check that chdir was called with original directory
        mock_chdir.assert_called_with(original_cwd)


class TestMainFunction(unittest.TestCase):
    """Test cases for main function"""
    
    @patch('src.ols_fetch_from_github.main_workflow.SBOWorkflowManager')
    @patch('builtins.print')
    def test_main_success(self, mock_print, mock_manager_class):
        """Test successful main function execution"""
        mock_manager = Mock()
        mock_manager.get_active_file.return_value = '/path/to/active.json'
        mock_manager_class.return_value = mock_manager
        
        result = main()
        
        self.assertEqual(result, '/path/to/active.json')
        mock_manager.run_workflow.assert_called_once()
        mock_manager.cleanup.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.SBOWorkflowManager')
    @patch('builtins.print')
    def test_main_keyboard_interrupt(self, mock_print, mock_manager_class):
        """Test main function with keyboard interrupt"""
        mock_manager = Mock()
        mock_manager.run_workflow.side_effect = KeyboardInterrupt()
        mock_manager_class.return_value = mock_manager
        
        result = main()
        
        self.assertIsNone(result)
        mock_manager.cleanup.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.SBOWorkflowManager')
    @patch('builtins.print')
    def test_main_exception(self, mock_print, mock_manager_class):
        """Test main function with exception"""
        mock_manager = Mock()
        mock_manager.run_workflow.side_effect = Exception("Test error")
        mock_manager_class.return_value = mock_manager
        
        result = main()
        
        self.assertIsNone(result)
        mock_manager.cleanup.assert_called_once()
    
    @patch('src.ols_fetch_from_github.main_workflow.SBOWorkflowManager')
    @patch('builtins.print')
    def test_main_no_active_file(self, mock_print, mock_manager_class):
        """Test main function when no active file is returned"""
        mock_manager = Mock()
        mock_manager.get_active_file.return_value = None
        mock_manager_class.return_value = mock_manager
        
        result = main()
        
        self.assertIsNone(result)
        mock_manager.cleanup.assert_called_once()


if __name__ == '__main__':
    unittest.main()